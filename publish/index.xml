<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XR-MATRIX</title>
    <link>https://xrmatrix.pages.dev/</link>
    <description>Recent content on XR-MATRIX</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 May 2022 22:00:51 +0800</lastBuildDate>
    <atom:link href="https://xrmatrix.pages.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hello World</title>
      <link>https://xrmatrix.pages.dev/posts/hello-world/</link>
      <pubDate>Thu, 05 May 2022 22:00:51 +0800</pubDate>
      <guid>https://xrmatrix.pages.dev/posts/hello-world/</guid>
      <description>Hello, Welcome!</description>
    </item>
    <item>
      <title>C&#43;&#43;多线程之死锁</title>
      <link>https://xrmatrix.pages.dev/posts/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</link>
      <pubDate>Sun, 04 Jul 2021 01:16:15 +0800</pubDate>
      <guid>https://xrmatrix.pages.dev/posts/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</guid>
      <description>问题 事情的起因来自于一次工作中的问题排查。场景简化为下图，一个工作线程负责接受并解析消息（线程A），然后将解析的消息重新打包并推送到发送线程（线程B），由发送线程将消息推送出去。后面测试过程中发现除了开头有消息被传送到下游以外，别的时间下游都没有收到任何消息。经过检查日志，发现第一个队列满了，而且在持续不断地因为队列已满发生丢消息的现象。&#xA;显然消息被卡在了线程A的消息队列中，无法传递给线程B。线程间消息的传递通过线程A所拥有的一根指向线程B的指针实现，照例来讲不会出什么问题。由于两个线程的消息队列均由锁实现，那么很容易推测是线程B自己的问题，可能发生了死锁。直接检查代码，在线程B的获取消息函数中找到如下代码。&#xA;void Get() { Mutex.lock(); Obj* newObj = list.top(); list.pop(); if(newObj != nullptr) { DoSomthingB(); return; // **No unlock here!** } Mutex.unlock(); } 很显然上面这段代码发生了死锁，如果代码进入if判断，那么函数直接结束，锁就不会被释放，造成了队列的死锁。这是一段非常非常经典的死锁代码，各种教科书上必有的经典反例，然而还是被我堂而皇之地写了出来而不自察。反思自身，还是对多线程编程不够熟悉，犯下这样的低级失误。 当然了，这里除了手工unlock，更应该鼓励使用RAII自动析构释放锁而不是手工释放～&#xA;由此引出两个需要巩固的地方：1. 死锁相关的理论知识；2. C++多线程编程中避免死锁的技巧。&#xA;死锁相关理论知识 死锁相关的理论知识已经在无数的操作系统相关教科书、博客、文章、公众号中提及，这边做一个简单梳理。推荐操作系统经典教科书&amp;quot;Operating System: Three Easy Pieces&amp;quot;，操作系统入门的最好教材之一。以下内容都来自于该书的第32章&amp;quot;Common Concurrency Problems&amp;quot;中关于死锁的部分。&#xA;大部分死锁问题之所以产生的究极原因可以归为两点：1. 在大型系统的代码中，其组件之间会产生异常复杂的依赖关系（dependencies），这份依赖关系会导致意料之外的死锁；2. 封装（encapsulation）的天性，那些隐藏了细节封装得很好的接口很可能是不安全的。&#xA;死锁的四个条件：&#xA;互斥(Mutual Exclusive): 线程对于资源的访问是独占式的，比如锁是一种资源，一个线程获取锁就是一种互斥行为。 占有且等待(Hold-and-wait): 一旦线程获取了某个资源，但是还处于等待状态(比如等待其他资源)，不会主动释放已经占有的资源。(比如一个线程需要获得两把锁，但是现在只获取了一把，它就会一直等啊等) 不可抢占(No preemption): 资源(比如锁)不能被强制从线程中移除(e.g. 朕(线程A)给了你(线程B)，才是你的，你不能抢) 循环等待(Circular wait): 在程序中，存在一个线程的循环，这个循环是这样的: 每一个线程都持有一些被下一个线程请求的资源，从而形成了一个等待链。 上述的四个条件是形成死锁的必要条件，只要打破一个，那么死锁就不会发生。&#xA;C++多线程编程中避免死锁 接下来是根据网上一些教材、博客整理的，从编程经验的角度如何避免死锁。&#xA;首先是T0级别的方法，不要用锁不要有缓冲区。最最简单粗暴的办法，从设计上尽量避免临界区的出现，从而杜绝了死锁的可能。然而这种方法可能在95%的场景下都不适用，多线程编程中想要避免临界区的出现几乎不可能。&#xA;如果T0方法失效，那么我们只能靠自己。什么叫靠自己呢，就是培养自己的“纪律性”。在处理多线程问题的时候可以参考下面几点策略：&#xA;如果不确定多线程场景的情况，那就先保证单线程场景下的正确性，然后再往多线程移植。不可能一下子写出完美的代码，要学会“小步快走”，最好能随写随测。 每一个加锁动作都需要配套的释放动作，同时注意检查代码中的分支。 尽量使用库里的锁实现，或者在自己已经封装好的锁上进行修改，无须重复造轮子。 尽量不要出现同时操作多把锁的情况，如果一定要出现那要注意锁的操作顺序。 写好单元测试，验证没有死锁情况的出现。 必要时可以借助一些工具验证死锁。 References [1] Remzi H. Arpaci-Dusseau and Andrea C.</description>
    </item>
    <item>
      <title>《你的知识需要管理》读书笔记</title>
      <link>https://xrmatrix.pages.dev/posts/%E4%BD%A0%E7%9A%84%E7%9F%A5%E8%AF%86%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 23 Apr 2021 01:17:26 +0800</pubDate>
      <guid>https://xrmatrix.pages.dev/posts/%E4%BD%A0%E7%9A%84%E7%9F%A5%E8%AF%86%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>第一章：个人知识问题 书本的第一章首先介绍了知识的重要性，提出现代人只有拥有知识才可以为自己带来价值。在开始正式篇章之前，有几个概念要搞清楚。&#xA;首先是数据、信息和知识之间的关系，即： - 数据：单纯的数据不能表达意思，比如37.5，单看这样一个数字毫无意义。 - 信息：建立了数据的环境后，列入37.5摄氏度表示的是腋下量过的提问。信息赋予了数据含义。 - 知识：经过实践证明的、可以用来决策和行动的信息。比如小女孩腋下提问37.5摄氏度，是否属于发烧的问题。&#xA;接下来，作者阐述了什么是显性知识、隐性知识，以及它们之间的转换。 所谓显性知识是指能够用语言、文字、肢体等方式表达清楚的知识。而隐性知识则是虽然知道如何做，但却很难告诉别人或者写明白、说明白的知识。 个人理解而言，显性知识相对好理解，比如书本中的、课堂里面的知识。而隐性知识则存在于我们的脑海中，是一种经验或者抽象，举个例子，提到计算机科学，脑中自然而然浮现出来一个整体的框架，包括计算机基础、编程语言、数据结构和算法、操作系统、数据库、计算机网络、分布式等等。隐性知识和显性知识存在转换的过程，总结起来就是： 显性知识（e.g. 书本） -&amp;gt; 隐性知识（大脑中） -&amp;gt;（显性化）-&amp;gt; 显性知识（e.g. 博客、演讲）-&amp;gt; 隐性知识（e.g. 谈话） 通过谈话、观察等多种学习方式学习隐性知识；同时，你应该主动促进你的知识从隐性向显性化转化，只有你有意识地显性化你的知识，你才能更深入地掌握知识，才能让别人知道你是某个领域的专家，才能赢得合作机会和新发展的平台。&amp;hellip; 隐性知识显性化应该成为现代人的一项必备能力。 隐性知识显性化能力是衡量一个知识工作者能力强弱的指标之一。&#xA;作者认为，作为一名知识工作者，最核心的竞争力就是处理信息和知识的能力于效率。而随着信息时代快速发展，信息的传递越来越没有障碍，知识工作者普遍缺乏两个能力： 1. 面对汪洋大海一般的信息，缺乏对信息的评估能力。 2. 缺乏知识基础，很难产生对信息的明确需求。 作者以知识的管理作为切入点，意在通过本书强化知识工作者的这两个能力，并提出了知识管理的五个阶段：学习、保存、共享、利用和创新。&#xA;第二章：学习知识 这一章是知识管理五个阶段的第一个阶段，学习知识。作者主要回答了以下几个问题 1. 为什么学习 2. 学什么知识 3. 学到哪种程度 4. 学习的方法和工具&#xA;为什么学 一个老生常谈的问题了。作者主要强调了现在知识更新周期非常快，我们应该贯彻终身学习理念，保持适当的应变能力，保证个人竞争力（创造个人价值和竞争优势）。 学什么 作者的策略是在有知识面的前提下兼顾知识的深度，并做好以下四点： 基础知识的掌握：一个现代社会的人需要掌握一定的基础知识，包括哲学、政治、经济、文化、法律、科学、数学、逻辑、阅读、表达等，同时也要培养形成自己的性格/技能/人生观/世界观。 知识基础的不牢固会成为你个人成长和进步的一大障碍。 确定知识学习的方向：每个人都有自己的个性，了解你自己，确定兴趣，然后在兴趣中做减法，聚焦于一点。 通常对于高中毕业以后的人，就没有必要再在自己最不擅长的地方下功夫了：因为近二十年的成长和发展，你的个性、气质接近定型，你最擅长和具有优势的东西也基本成形，从这个时候开始你就应该去发挥自己的优势。 作者提供了一些了解自己的方法： 价值观是什么（参考价值观表）。 个人目标是什么（由价值观提供）。 性格是什么（参加一些性格测试 他人的评价（优秀的部分） 学到什么程度 首先需要大家认识到一个事实：原来有竞争优势的知识会成为常识，这就要求每个人的学习应该是持续的。 通常来讲，学习的目标有两个 成为一个知识领域的专家 建立知识结构 - 金字塔架构 学习方法 有笔记式选手，有说话式选手 探索自己的适合的方法 考虑知识获取的成本，金钱和时间 学习方法模型：基础入手（教材、入门、论文），了解全貌（搜索引擎），跟踪并掌握该领域的最新知识（信息渠道、专家交流），实践（工作，同时有意识提升自己的显性化的知识水平和能力，对已掌握的知识要多说多写，争取能够用最通俗的语言讲清楚复杂的问题） 必要的学习能力：1. 检索信息和知识。提高对一个知识领域掌握的广度和深度，掌握搜索引擎，不能太依赖搜索引擎。2. 评估信息和知识的能力。设置好过滤器，掌握评估技巧。 学习方法 - 太过个人化 专家交流值得加强 学习工具 - 搜索引擎/维基百科类网站/问答型网站/各大论文库/信息评价类网站/信息订阅RSS 第三章：保存知识 这一章作者提出的一些工具有点过时，但是思想和方法仍值得参考。 保存知识的主要问题在于无限制的保存，比如动辄上百G的学习资料，而这些资料在保存到硬盘以后就再也没有打开过。</description>
    </item>
    <item>
      <title>《刻意学习：如何从新手到大师》读书笔记</title>
      <link>https://xrmatrix.pages.dev/posts/%E5%88%BB%E6%84%8F%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 02 Sep 2019 07:27:51 +0800</pubDate>
      <guid>https://xrmatrix.pages.dev/posts/%E5%88%BB%E6%84%8F%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>开这个系列是因为暑假中的一个想法。当时在刷leetcode、准备面试什么的，刷题刷得很痛苦，有的时候就会发呆想一些有的没的，甚至怀疑自己这样的学习方式是不是正确的。&#xA;随后在某论坛看到了一个关于使用刻意学习法学习DOTA的帖子。其中主人公是一个印度小哥，他从来没有接触过MOBA类游戏，完全0基础。他使用刻意学习法，利用3个月的时间，从MOBA小白一跃成为DOTA对线高手（中路影魔solo单杀万古流芳选手三次）。&#xA;当时论坛里面一片“这就是天才啊”的声音，我在感叹印度小哥厉害的同时，也对这个刻意学习法（Deliberate Practice）和Dr. Anders Ericsson 产生了巨大的好奇。究竟是怎样的一个学习法可以产生这样的效果？我自己的学习方式是怎么样的？我自己的学习方式有什么有缺点？有没有改进的空间？&#xA;抱着这样的问题，我读了这本《刻意学习：如何从新手到大师》，并做了一系列笔记，包含刻意学习法本身的讨论，也有对自己学习方式的思考。文章中所有引用部分都来自于书中或网上资料。&#xA;“1万小时定律” 这是书中序的部分所讲的内容，一上来就提到了“1万小时定律”。&#xA;我在很早以前就听说过这个所谓“1万小时定律”，远远早于我听说“刻意训练”。&#xA;一万小时定律是指作家格拉德威尔在《异类》一书中指出：“人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1万小时的锤炼是任何人从平凡变成超凡的必要条件”。要成为某个领域的专家，需要10000小时，按比例计算就是：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。&#xA;我向来知道“熟能生巧”的重要性，因此在我第一次听说这个理论的时候，内心默认是理解为“想要在一个领域内成为专家，就要花大量的时间在里面。”至于这个时间具体是多少、这个时间怎么花，我是一概不知的。&#xA;然而在书中这样写道：&#xA;真相是，从来不存在1万小时定律，它仅仅是畅销书作家对心理科学研究的一次不太严谨的演绎而已。&#xA;进一步解释要从源头说起，简单来讲，“1万小时定律”的产生源自于1978年诺贝尔奖得主Herbert Simon与合作者William Chase发表的一片关于国际象棋大师与新手比较的论文。简单来概括，这篇论文发现国际象棋大师的专业长时记忆（如摆盘、复盘）显著强于一级棋手和新手。而获得这些专业知识大概需要10年。这就是西蒙的“十年定律”。&#xA;随后，本书的作者，埃里克森于1993年发表了一篇有关音乐学院三组学生的研究结果的论文。&#xA;……到20岁的时候，卓越的演奏者已经练习了1万小时，……那些比较优秀的学生练习的时间是8000小时，而那些未来的音乐教师练习的时间只有4000小时。&#xA;后来，可以料到，作家格拉德威尔在看到了埃里克森的研究之后，得到了所谓“1万小时定律”的理论。这个序中感觉有点把格拉德威尔描述成一个肤浅的畅销书作家，和只想用一些噱头来博取大众眼球的无良作家。这一部分有待考证。&#xA;“1万小时定律”的问题 在了解了这个定律的简单起源以后，序中简要阐述了“1万小时定律”所忽视的几点问题：&#xA;不同专业领域习得专业技能的时间和所需要的练习时间，并不是“1万小时”这个最低阈值。它可能是几千个小时（如优秀专业演员），也可以是几百个小时（如记忆数字）。&#xA;成功与否和练习时长并不完全成正比，“1万小时定律“忽视了天赋（或者说天才）也是一个重要的影响因素。比如体育项目，身高160cm的男子很难成为优秀的篮球运动员，这并不是一定时间和简单的练习可以弥补的。&#xA;”1万小时定律“没有指出学习（练习）方法的重要性。生活中有许多我们所谓的”死读书“的人，或者”看似很努力，实则没有什么成就的人“。有时候我们会简单把这些人归为”天赋所限“，实则是没有发现更加有效的训练方法，他们的方法是”机械的，缺乏针对性和技巧性“。&#xA;而对于当今市面上的所谓学习方法的畅销书，序中也给出了这样的评价：&#xA;熟悉写作技巧的畅销书作者常常会用一个_清晰的行动准则_，如“练习1万小时成为专家”、“21天养成好习惯”等来激发你的行动。但是对于究竟有多少人能够坚持1万小时，1万小时是否真的引向成功，坚持1万小时的关键节点，以及1万小时练习的本质是什么却置之不理。这些畅销书作者略过不谈的_细节_，恰恰是科学着墨最多，也是对人们提升自我最有帮助的地方。&#xA;刻意训练的核心观点 那些处于中上水平的人们，拥有一种较强的记忆能力：长时记忆。长时记忆正是区分卓越者与一般人的一个重要能力，它才是可以练习的指向与本质。&#xA;简单理解来讲，想要在某一领域内成为中上水平者，最终的目标便是在从事这个领域工作的时候，能够用调动起更大容量的工作记忆。&#xA;最近不管是生活还是学习也好，我经常会想，要是自己的记忆力能更好就好了。这样我学过的课程也不会忘记，经历的生活片段也不会渐渐离我远去。我也很羡慕那些过目不忘的人。举个例子，我和一位同事三个月前一起做过一个项目。三个月后的今天，他仍能记起很多关于项目的细节，包括代码、实施过程、验证过程、最终结果如何等等。但是我就没有记住，许多细节都要靠回翻文档来确定，甚至项目中的算法我都不能流畅地写出来。这常常让我产生一种挫败感。&#xA;如果说专家和准专家们已将自己的大脑升级了，工作记忆内存条可以同时调用一块SSD硬盘来当虚拟内存用，那么那些专业领域的新手们往往还是在使用小内存跑。&#xA;那么问题来了，这种长时记忆的能力能否人为培养呢？像我们这种成年人能否再像小孩子一样激发自己的潜力，使自己的记忆力获得长足进步呢？&#xA;埃里克森认为，这种长时记忆能力，是于具体专业领域密切相关的，且可以通过刻意训练习得。&#xA;只要你努力，经过几十小时到成千上万小时不等的艰苦努力，就能买来那款可以被工作记忆内存条调用，当作虚拟内存使唤的SSD硬盘，即长时记忆。&#xA;人类的潜力 在指明具体的训练方法之前，必须指出，训练方法也是随着人类文明进步而动态进步的。在任何一个领域中（比如运动、计算机、音乐等等），都在持续不断地出现变得更加卓越的办法，以抬高人们认为可以做到的“门槛”。&#xA;简单举个例子，以前成为一个优秀的程序员，可能只需要了解一门语言，如C++。现在，一个优秀的程序员必需了解多门语言，会C++的同时，也要会Java，会Swift，也要看得懂网络编程语言（如HTML、JS、PHP等），也要会胶水语言（如Python等）。更夸张的是，可能以前优秀程序员是从本科时候开始接触编程语言的，现在卓越的程序员是从高中，甚至初中就开始接触相关方面的知识。&#xA;人类的潜力，随着一代又一代的进步，也在扩张和提高。&#xA;如何买得起这块硬盘呢？ 那么，这个刻意训练，到底怎么训练呢？&#xA;首先来讲讲长时记忆的培训，要做到以下：&#xA;快速理解自己领域内的单词与术语。这里可以采取思维导图的模式，从几个核心概念进行发散，逐步细分到各个分支。&#xA;对于专业领域的知识，要学会提炼其背后的思想，或者说大的框架。比如专家级的开发者善用设计模式，又比如在理解计算机网络的时候注意分层思想。&#xA;大量的练习。大量的练习可以提升调取长时记忆的速度。比如写了十遍二分法的人写第十一遍，理论上讲比只写了一遍写第二遍的人要快。&#xA;情景学习 上面的几点还是太过空洞，接下来进行更加全面的总结。&#xA;首先要介绍认知复杂度这一概念。人类对任何事物都有一个认知，那些比较简单、容易理解的事物，认知复杂度就比较低，如象棋、钢琴、篮球、驾驶等等。而有些事物则有一个较高的认知复杂度，如销售、管理、辩论等等。不同复杂度的事物，练习方式也不同。&#xA;而如果用人的能力来理解认知复杂度，那么，认知复杂度高的人，思维能力也高度复杂化，对客观世界的理解能力就越强。但是，认知复杂度的培养也是需要一个过程的，而且不是普通的学习方法就能实现的，这个过程可以概括为“情景学习”。&#xA;所谓情景学习，说白了就是，你要学习的东西在实际应用中是什么场景，那么你就应该在什么样的场景中学习这些东西。比如你要学习编程，就应该在Github里面学习，因为你以后编程就是通过Github。再比如，你要学习篮球，这不是坐在家里看几个篮球视频就能学会的，球场才是你提高篮球水平的最佳场所。&#xA;成人的最佳学习方式并非独自练习，而是在情景中学习。有效学习是进入相关情境，找到自己的“学习共同体”，学习者最开始围绕重要成员转，做一些外围工作，随着技能增长，进入学习共同体圈子的核心，逐步做更重要的工作，最终成为专家。&#xA;下面是“情景学习”的几个要点：&#xA;找到你的学习共同体。有效的学习不是关门苦练，而是找到属于自己的学习小团体。 隐性知识显性化。这个有点晦涩，简单来讲就是了解你的学习策略。 模仿榜样。这一点其实很重要，一个好的导师的作用非常巨大。这个榜样可以是现实中的，也可以是网上的导师。 培养多样性。有些情况下一种情景可能不够，需要在多种情景中实践，强调学习广阔的应用范围。 “情景学习”对于我们其实并不陌生，因为中国义务教育的一些模式就十分符合”情景学习“的要求。首先，学生是以班级为单位进行共同学习的，这就符合了学习共同体这一点。有时候班级这个团体又太大了，因此衍生出“学习小组”的概念。那么，“学习氛围”也自然而然的产生了。学习氛围的好坏决定了这个小团体的潜力。&#xA;其次，榜样的力量。一个班级的榜样由一群老师组成，具体来讲有班主任、各科老师、生活老师等等，他们是一个班级的核心，起着引导、鼓励、督促等多个作用。&#xA;就我个人的学习经历，以高中为例，我觉得一、三点是做得很好的，但是对于二、四点，我们学校是做得不够的。老师们并没有专门针对学习策略进行一个科学的指导，很多策略都是由学生自己在摸爬滚打中摸索出来，有些成功的学生可能很幸运，摸到了适合自己的学习路径，但是更多的学生从高一开始就浑浑噩噩，灌输成了他们接受知识的主要来源。同时，对于学习的阶段性目标和长期目标，也没有一个很好的、定制化的规划，大多数靠学生自己完成。&#xA;再举一个我暑假leetcode刷题的例子。刷题的时候我做了下面几件事情：&#xA;学习共同体。加了一个leetcode的微信群，找了Github上的repository，还有一些刷题论坛和刷题网。 学习策略。主要分为两大块，理论知识和编程能力。理论知识主要是MIT的公开课资源、网上的理论知识资源、还有刷相关书籍三块。编程能力主要靠刷leetcode，看GitHub上的刷题指南。 模仿榜样。这一部分是我所欠缺的，一直缺少一个可以交流的、以之为目标的榜样。 培养多样性。目前的练习环境有leetcode，Github，本地的IDE。感觉对Github的使用还有所欠缺，需要继续扩展，最好可以围绕一个项目展开。 下一集预告 第一部分的全部内容来自于这本书的推荐序，下一部分将会正式从书中正文第一章开始。&#xA;Reference 《刻意训练：如何从新手到大师》推荐序 一万小时定律 - MBA智库百科 「一万小时定律」真的适合所有的领域吗？ </description>
    </item>
  </channel>
</rss>
